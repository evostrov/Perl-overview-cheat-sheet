# Perl-overview-cheat-sheet

## Namespaces, области видимости
**symbol tables (таблица имен)** - хеш для хранения глобальных переменных (в том числе и других таблиц имен), еще ее называют пакет (package) - `%Module::`
**lexical scopes (область лексической(текстовой) видимости)** - `my, state` анонимная временная память, прикрепленная к блоку коду
**dynamic scope (Динамическая область видимости)** - `local`, переопределяет перменную внутри текущего блока кода, т.е. охватывание переменной определяется динамически на этапе выполнения(порядком вызова блоков кода), а не текстовой вложенностью.

Переменные лексической области `my, state` видимости не принадлежат пакетам.
Пакетные(глобальные) переменные `$Package::var` или `$main::var` - создаются `$var = 1;` - будет работать только без `use strict;`
`our` - фактически глобальная переменная маскирующаяся под лексическую.
`local` - не может переопределять (override) лексическую переменную, только переменную пакета.

При обращении к переменной Perl ищет сначала в текущем блоке переменную в лексической области, если нет - в вышестоящем (higher) блоке (охватываюем текущий), если нет - в единице компиляции (файл или eval STRING), иначе ошибка компиляции (требует(require) указать имя пакета переменной явно).
Но если не используется `use strict` - ищет объявление пакета и пробует взять `$Package::var` или если пакета нет `$main::var`.
В случае, если единица компиляции eval STRING - то продолжает поиск по более широким лексическим областям.

```perl
$var = 0;
print $var. "\n"; # 0
my $var = 1;
print $var. "\n"; # 1
print $main::var. "\n"; # 0
{
    print $var. "\n"; # 1 - ищет из лексической области видимости верхнего блока сначала, 
                      # а только потом уже берет из пакета, если в лексической области видимости нет
    our $var = 2;
    print $var. "\n"; # 2
}
print $main::var. "\n"; # 2
```

Область видимости `state` эквивалентна области видимости `my`, но переменная объявленная `state` не будет переинициализирована в рамках программы при повторном выполнении кода

```perl
use feature 'state';
gimme_another(); # 1
gimme_another(); # 2
sub gimme_another {
  state $x;
  print ++$x, "\n";
}
```


## Пакеты
Все пакеты хранятся в таблице главного пакета `main`, и еще он ссылается сам на себя 
```perl
$main::Test::test;
$main::main::test == $main::test == $::test;  # и так далее.
```
`*` - разыменовывающий префикс всех типов, предоставляет доступ к записям глобальной таблицы имен (typeglobs)
Что бы переопределить код функции пакета надо сделать:
`*Package::method = sub {...};`
Операция
`*test = $Test::{test} # создаст и скопирует значения $main::test, @main::test, %main::test, &main::test.`
Можно еще так записать:
`*test = *Test::test; # тогда будут созданы переменные внутри Test дополнительно.`

`Test::Module::name` - здесь первые два идентификатора это указатели вложенных таблиц имен, а последний является именем переменной в самой глубоковложенной таблице.


## Скаляры. Форматы записи чисел
```perl
12345
12345.67
.23E-10
0xffff шестнадцатеричная запись
0377 восьмеричная запись.
0b1010 двоичная
1_234_567_890 подчерк для удобства чтения.
```

## Ссылки. Разыименования
```perl
my $hash = { key => [ 0, 1, 2 ] };
$hash->{key}->[0];
$hash->{key}[0]; # Допускается не использовать -> для разыименовывания вложенных(enclosed, embeded) структур (data)
$$hash{key}[0]; # Еще способ
```

## Перекрестные ссылки
Perl имеет механизм чистки уже неиспользуемых переменных. Работает просто — новая переменная всегда имеет счетчик ссылок, равный единице. Этот счетчик увеличивается на единицу, как только вы ставите на ту переменную ссылку или где-то используете эту переменую в функции, а саму функцию передаете куда либо еще — всё это отражается на счетчике. И пока этот счетчик не равен нулю — perl не освобождает память этой переменной. Счетчик также уменьшается на единицу, как только удаляется ссылка на переменную или, как во втором примере — удаляется ссылка на функцию, ее использующую, либо когда переменная становится не нужной после блока {}.

Перекрестные сылки приводят к утечкам памяти. Возникают в случаях: когда функция обращается к переменной которая хранить ссылку на функцию (1), когда переменная содержит ссылку на другу переменную, которая ссылается на текущую (2)

```perl
#1
{
  my $ref = {};
  $ref->{func} = sub {
    ...
    $ref->{foo} = 2;
    ...
  }
}
```
```perl
#2
{
  my $a = {};
  my $b = {};
  $a->{ref} = $b;
  $b->{ref} = $a;
}
```
Что бы избежать случая (2) надо испльзовать undef $b->{ref} перед завершением блока кода.
Что бы избежать случая (1) можно использовать другую перменную или use Scalar::Util 'weaken';.


## Контекст в Perl
Всякая оперция выполняется в каком-либо контексте. Есть два основных: скалярный, списочный. И еще void (пустой) и булевый.
Функция wantarray - служит для определения контекста вызова текущего блока кода (функции).
Функция scalar - позволяет принудительно(force) вызывать в скалярном контексте.
`@list + 0` - неявное(implicitly) использование в скалярном контексте.
Булев контекст используется везде где проверяется истинность или ложность выражения. Скаляр в булевом контексте ложь если он 0, '', '0'. Undef всегда приводится к 0 или '', в зависимости от типа проверки. Список в булевом контексте, сначала приводится(convert) к скаляру, содержащему значение равное количеству элементов списка.
Пустой контекст - контекст в котором не требует возвращать значение.
При преобразовании строки в число используются все цифры с начала строки до первого не цифрового символа.
```perl
'a1' == 0
'12a3' == 12
```

## Функции
К функциям можно обращаться так `Package::func $arg, $arg1;` - без прототипирования, и даже без указания `Package`.

### Прототипы 
\'символ' - параметр с типом 'символ'(@ или %)
'@' или '%' - все оставшиеся параметры как список
'$' - скаляр
'&' - безымянная подпрограмма
'*' - ссылка на таблицу имен
';' - разграничитель обязательных и не обязательных параметров.

### Аттрибуты функций
```perl
use Attribute::Handlers;
sub isAuth : ATTR(CODE) {...}
sub my_sub : isAuth {...}
```

## Циклы
```perl
print $i++ while $i <= 10;
print $j++ until $j > 10;
do { $line = <STDIN>; ... } until !defined($line) || $line eq ".\n"
```

функция `each` - возвращает в списочном контексте каждое следующее значение ключа и значения хеша, при этом если не будет завершена итерация по хешу (не дойти до момента когда функция вернет пустой массив) то итератор хеша не сброситься и при следующем вызове этой функции в любом месте итерация продолжиться с момента на котором прервалась.


## Использование модулей
`use Module;` по сути эквивалентно коду: `BEGIN { require Module; Module::import() }`
Импорт обычно заключается в том, что делает в текущем пакете алиасы для экспортируемых функций.
`*CurModule::import_sub = \&Module::export_sub;`
`use Module ();` - по сути эквивалентно коду: `BEGIN { require Module }`

### Наследование
`parent` выполняет все тоже что и base:
```perl
package Baz;
use parent qw(Foo Bar); 

# по сути это тоже что и:
package Baz;
BEGIN {
    require Foo;
    require Bar;
    push @ISA, qw(Foo Bar);
}
```
Но parent сделан в замену base, так как в коде base накопился мусор. Поэтому лучше использовать parent.

Еще в base умеет работать с <fields> pragma:
```perl
package Bar;
use base 'Foo';
use fields qw(baz _Bar_private); # not shared with Foo
sub new {
    my $class = shift;
    my $self = fields::new($class);
    $self->SUPER::new(); # init base fields
    $self->{baz} = 10; # init own fields
    $self->{_Bar_private} = "this is Bar's secret";
    return $self;
}
```


## Фазы компиляции Perl 
BEGIN, UNITCHECK, CHECK, INIT and END
* BEGIN - выполняется первым даже до того как остальная часть файла будет прочитана
* UNITCHECK - выполняется после компиляции блока кода, за которым он находится
* CHECK - после компиляции
* INIT - непосредственно перед запуском кода
* END - выполняется после завершения программы и перед выходом из интерпретатора, содержит код выхода в $? , но код внутри этого блока все равно компилируется до выполнения и он может перекрывать код в блоке BEGIN например.


## Операторы
### Порядок вычисления
Выполняется на основе приоритета операций, если приоритет одинаковый, то на основе ассоциативности.
Пример левой ассоциавности "->": `$obj->method1->method2;` - снача будут выполняться выражения, которые находятся левее.

Оператор comma (запятая) - возвращает то что справа.
`my $x  = ( 1, 2, 4, 8 ); # x == 8` - скалярный контекст, скобки еще не значат что это список
`my $x  = () = ( 1, 2, 4, 8 ); # x == 4` - массив в скалярном контексте


### Битовые операторы
* | побитовое ИЛИ
* & побитовое И
* ^ побитовое XOR
* ~ побитовая инверсия
* << сдвиг влево
* \>\> сдвиг вправо


### Оператор повторения
Оператор "x" в скалярном контексте берет скаляр, повторяет и возвращает строку. В списочном - берет список, повторяет и возвращает список.
```perl
my $b = (1, 5, 7) x 2; # $b == 77
my @a = qw/ 1 5 7 /;
my $b = @a x 2; # $b == 33

@ones = (1) x 80; # a list of 80 1's
@ones = (5) x @ones; # set all elements to 5
```

### Логические операторы
* && - возвращает первый ложный аргумент, если ложь, последний аргумент если истина
* || - возвращает последний аргумент, если ложь, первый истинный аргумент, если истина


## Вычисления
`3.3-3.3 != 0;` - может быть истина - т.к. в результате вычисления двух чисел с плавающей запятой останется очень маленькое значение


## Работа с фалами и каталогами
```perl
open FILEHANDLE,EXPR
open FILEHANDLE,MODE,EXPR
open FILEHANDLE,MODE,EXPR,LIST
open FILEHANDLE,MODE,REFERENCE
open FILEHANDLE
```

* `>` - запись с затиранием
* `>>` - дозапись в конец файла
* `<` - чтение
* `+<, +>` - чтение запись одновременно. +> - будет затирать файл.

```perl
read FILEHANDLE,SCALAR,LENGTH,OFFSET
read FILEHANDLE,SCALAR,LENGTH
read # читает из FH в SCALAR

opendir DIRHANDLE,EXPR
readdir DIRHANDLE

select FH # делает FH для печати по умолчанию

if ( -e "file" ) {..} # проверка существования файла/директории
if ( -d "dir" ) {..} # проверка существования директории
if ( -s "dir" ) {..} # вернуть размер файла/директории - можно так проверить что директория существует

binmode $fh, ':utf8'; # указывает что поток ввода или вывода в unicode. При вводе делает decode utf8 и ставит флаг.
```

## Сигналы
Сигналы используются для межпроцессорных взаимодействий или обработки прерываний от системы или пользователя. Для установки пользовательских обработчиков сигналов использоуется перемернная %SIG.

Установка обработчика
```perl
$SIG{'INT'} = sub {...};
$SIG{'INT'} = 'IGNORE'; # Программа будет игнорить прерывание Ctrl+C
$SIG{'INT'} = 'DEFAULT'; # Программа выполнит дефолтный обработчик при Ctrl+C
```

Послать сигналы процессам
```perl
kill SIGNAL, LIST
kill SIGNAL
```

`$SIG{__DIE__}` - позволяет установить обработчик перед тем как программа завершится по die, можно например воткнуть другой die.


## Опции командной строки (Ключи интерпретатора)
- `-I` (Заглавная И Анг) -- Include lib
- `-e` -- компиляция и запуск текста из строки
- `-M` -- `use Module;`
- `-m` -- use Module ();
- `-n` -- читает строки из файлов переданных в параметрах или из пайпа и запускает программу в цикле прохода по этим строкам, например: perl  -ne 'print "str:$_"' ~/pls/text1.txt ~/pls/text.txt - напечатает str:%строка из файлов%
- `-a` -- автоматически разделяет строки на массивы через пробел и кладет результат в @F, неявно включает -n
- `-F` -- тоже что -a + указать паттерн для разделения, соотвественно неявно включает -an
- `-p` -- делает тоже что и -n + по умолчанию печатает
- `-l` (Прописная Л Анг) -- управляет обработкой символов начала новой строки (chomp). Если этот ключ задан вместе с -p или -n, Perl при вводе автоматически удаляет символ начала новой строки (заданный в специальной переменной $\). Одновременно при выводе оператором print тот же символ добавляется в конец строки.
- `-0[цифры](ноль)` — задает разделитель входных записей как символ, заданный восьмеричным представлением (этот разделитель также содержится в специальной переменной Perl $/). По умолчанию в качестве разделителя выступает символ \n. Если ключ -0 задан без последующих цифр, то используется символ \0.
- `-X` -- отключить все варнинги независимо от use warnings;
- `-C` -- управлние юникодными фичами
- `-c` -- компиляция
- `-d` -- дебаг


## ООП
- `$obj->can('method)` - проверить имеет ли объект метод и вернуть на него ссылку
- `sub DESTROY {...}` - деструктор объектов
- `protected` - методы класса доступные только из потомков.

### ООП. Множественное наследование
Дано:
```perl
package Equine;
sub color() {…}

package Donkey;
use base 'Equine’;

package Horse;
use base 'Equine';
sub color {...}
```
Используем множественное наследование:
```perl
use base qw/ Donkey Horse /; # первым будет найден Equine::color
use base qw/ Horse Donkey /;# первым будет найден Horse::color
```

Поэтому лучше использовать use mro 'c3'; - порядок - просмотр по горизонтальным уровням в порядке возрастания, т.е. так Horse Donkey Equine или Donkey Horse Equine - всегда будет найден первым `Horse::color`


## regex
http://citforum.ru/internet/perl_tut/re.shtml 
http://citforum.ru/internet/perl/regexp/ 
- `(?!шаблон)` - "заглядывание" вперед по отрицанию. (\d)(?!x) - найти цифру за которой не стоит x.
- `(?=шаблон)` -  "заглядывание" вперед. Например /\w+(?=\t)/ соответствует слову, за которым идет табуляция, но символ '\t' не включается в результат.
- `\d{2,}?` - здесь ? делает выражение не жадным (not greedy) а совсем не означает что все что находится перед ним может отсутствовать.


Внутри регулярного выражения можно указывать "подшаблоны" заключая их в круглые скобки и ссылаться на них как '\номер' Первая скобка обозначается как '\1'.

### Модификаторы
- `/i` игнорировать регистр
- `/x` игнорировать пропуски в шаблоне и разрешить комментарии.
- `/g` модификатор разрешающий выполнение поиска/замены везде, где это возможно
- `/gc` не сбрасывается позиция при неудачном поиске
- `/s` разрешается совпрадение . с \n, игнорируется $*
- `/m` разрешить совпадение ^ и $ для начала и конца строки во внутренних переводах строк
- `/o` однократная компиляция
- `/e` правая часть `s///` представляет собой выполняемый код, например `s/../sprintf(..)/e;`
- `/ee` правая часть `s///` выполняется, после чего возвращаемое значение интерпретируется снова

### Матчинг. Используемые переменные
- `$+` - обозначает последнее совпадение, т.е. последняя из переменных $1, $2..
- `$&` - все совпадение
- $\` - все до совпадения
- `$'` - все после совпадения
- `$1` и `$2` и т.д. содержат значения который матчастся регулярками внутри скобок.
- `/(.)+/` - в таком случае $1 будет содержать послений подходящий символ (только один).

- `qr//` - возвращает скомпилиорванное регулярное выражение, т.е. интерпояция строки выполняется один раз при компиляции.
- `tr/список1/список2/ == y/список1/список2/` - вообще говоря это не регулярка, а выражение которое производит замену символа из списка1 на соответствующий ему из второго. Переменные не интерполируются.
- `tr/O-9/abc/` эквивалентна команде `tr/0123456789/abcccccccc/`
- `tr/abc/0-9/` эквивалентна команде `tr/abc/012/`
- `$digit_counter=($text =~ tr/0-9//);`  - ничего не удалит, но подсчитает количество цифр в строке


## Форматирование строк printf sprintf
```perl
# Спецификаторы
printf "%c\n", 65; # Печать символа по ascii коду - A латинская
printf "%d\n", -1234.567890; # целое со знаком в десятичной - '-1234'
printf "%u\n", 1234.567890; # целое без знака - '1234'
printf "%b\n", 6; # целое без знака в двоичной - '110'
printf "%o\n", 16; # целое без знака в восьмиричной - '20'
printf "%x\n", 176; # целое без знака в шестнадцатиричной - 'b0'
printf "%X\n", 176; # целое без знака в шестнадцатиричной - 'B0'
printf "%e\n", -1234.567890; # число с плавающей точкой, мантиссой и порядком - '-1.234568e+03'
printf "%E\n", -1234.567890; # число с плавающей точкой, мантиссой и порядком - '-1.234568E+03'
printf "%f\n", -1.234568E+03; # число с плавающей точкой в фиксированном формате без указания порядка - '-1234.568000'
printf "%g\n", -1.234568E+03; # тоже что %f либо %e - '-1234.57' - в формате с фиксированной точкой печатает только 6 цифр знак и точку
printf "%g\n", -1.234568E+15; # тоже что %f либо %e - '-1.23457e+15'
printf "%G\n", -1.234568E+15; # тоже что %g - '-1.23457E+15'


# Флаги
printf "%4u\n", 111; # минимальный размер поля 4 - ' 111'
printf "%04d\n", 111; # минимальный размер поля 4 вместо прообоела использовать 0 - '0111'
printf "%.4u\n", 111; # число разрядов - '0111'
printf "%.4f\n", 0.123456; # число разрядов - '0.1235'
printf "%.4s\n", 'string'; # число символов в байтах - 'stri'
printf "%lu\n", 111; # интерпретировать целое значение как тип long или unsigned long языка C - '111'
printf "%hu\n", 111; # интерпретировать целое значение как тип short или unsigned short языка C - '111'
printf "% d\n", 111; # использовать префикс "пробел" перед положительными числами - ' 111'
printf "%+d\n", 111; # использовать префикс "+" перед положительными числами - '+111'
printf "%#o\n", 16; # добавить префикс - '020'
printf "%#x\n", 176; # добавить префикс - '0xb0'
```

## Часто используемые функции
autodie - делает так, что бы встроенные функции (например open, close) вохвращали die в случае ошибки.
exec - код следующий после этой команды не выполнится


## Округление
```perl
use POSIX;
say ceil 5.16; # 6
say ceil 5.96; # 6
say floor 5.16; # 5
say floor 5.96; # 5
say round 5.16; # 5
say round 5.96; # 6
```

## Exporter
@EXPORT_OK - массив с функциями которые пользователь должен явно указать при подключении, @EXPORT - импортируются неявно при use.


## DBI
Можно получать данные используя prepare, execute, fetch row - это позволяет не создавать самостоятельно переменную для хранения все выборки а обработать результат по результатам. Select - выполняет все эти действия и возвращает результат одним разом.


## Специальные(встроенные) перменные
- `$$` - текущий pid
- `$?` - код завершения дочернего процесса ( или ${^CHILD_ERROR_NATIVE} )
- `$|` - буфер вывода
- `$!` - содержит текст ошибки при работе с фалами
- `$\` - Символ, добавляемый print после вывода всех параметров
- `$/` - Символ, разделитель строк, по умолчанию \n
- `$]` - версия Perl

- `%INC` - Хэш с подключеными модулями, ключ - название, значение - путь до файла
- `@INC` - список директорий для поиска модулей
- `@ISA` - список предков, @Module::ISA - вернет только непосредственных предков, Class::ISA::super_path('Module')  - вернет полный список, а проверка  Module->isa('ParentModule') - вернет истину несмотря на то что ParentModule - не прямой предок.
- `%ENV` - переменные окружения. Изменения, которые скрипт делает в массиве %ENV, не по­влияют на исходные переменные окружения. Иными словами, после оконча­ния работы скрипта переменные окружения системы не изменятся.


## Moose - в общем виде
Moose meta-programming при создании класса создается мета объект класса `Moose::Meta::Class`, который доступен через `Class->meta`. Это позволяет на этапе копиляции менять код или получать информацию о коде (The metaclass object provides an introspection API for your class).
`Class::MOP::Class` - позволяет во время выполнения добавлять или удалять метод классу. Можно даже класс на лету (runtime) создать.
Используется в случае когда конфиги классов были объявлены (to declare, определять - to determine) в них самих и нужно было получить все конфиги потомков пройдясь по списку потомков (subclasses) основного класса.

use namespace::autoclean;` - не позволяет ипортированным функциям становиться методами класса
`no Moose` - тоже самое но только для функций импортированных из use Moose, первое предпочтительнее
